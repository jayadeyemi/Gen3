{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "21bf63c1",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "usage: ipykernel_launcher.py [-h] [--json] root\n",
      "ipykernel_launcher.py: error: the following arguments are required: root\n"
     ]
    },
    {
     "ename": "SystemExit",
     "evalue": "2",
     "output_type": "error",
     "traceback": [
      "An exception has occurred, use %tb to see the full traceback.\n",
      "\u001b[1;31mSystemExit\u001b[0m\u001b[1;31m:\u001b[0m 2\n"
     ]
    }
   ],
   "source": [
    "#!/usr/bin/env python3\n",
    "\"\"\"\n",
    "tf_inventory.py  –  Walk a Terraform code base and list\n",
    "  • variables (definitions)           – file path\n",
    "  • modules   (label → source)        – file path\n",
    "  • resources (type.name)             – file path\n",
    "\n",
    "USAGE:\n",
    "    python tf_inventory.py /path/to/terraform/root\n",
    "\"\"\"\n",
    "\n",
    "import argparse\n",
    "import json\n",
    "import pathlib\n",
    "import sys\n",
    "from collections import defaultdict\n",
    "\n",
    "try:\n",
    "    import hcl2\n",
    "except ModuleNotFoundError:\n",
    "    sys.stderr.write(\"❌  The package 'python-hcl2' is required.  \"\n",
    "                     \"Install it with:  pip install python-hcl2\\n\")\n",
    "    sys.exit(1)\n",
    "\n",
    "\n",
    "def load_tf_file(path: pathlib.Path):\n",
    "    \"\"\"Safely load & parse a .tf file, returning an empty dict on failure.\"\"\"\n",
    "    try:\n",
    "        with path.open(\"r\", encoding=\"utf-8\") as fp:\n",
    "            return hcl2.load(fp)\n",
    "    except Exception as exc:  # pylint: disable=broad-except\n",
    "        sys.stderr.write(f\"⚠️  Skipping {path} – {exc}\\n\")\n",
    "        return {}\n",
    "\n",
    "\n",
    "def scan_directory(root: pathlib.Path):\n",
    "    \"\"\"Walk the tree and collect variables, modules, and resources.\"\"\"\n",
    "    collected = {\n",
    "        \"variables\": defaultdict(list),   # var_name -> [paths]\n",
    "        \"modules\":   defaultdict(list),   # module_label -> [(source, path)]\n",
    "        \"resources\": defaultdict(list),   # \"type.name\" -> [paths]\n",
    "    }\n",
    "\n",
    "    for tf_path in root.rglob(\"*.tf\"):\n",
    "        body = load_tf_file(tf_path)\n",
    "\n",
    "        # 1. Variables\n",
    "        for var_blk in body.get(\"variable\", []):\n",
    "            for var_name in var_blk:\n",
    "                collected[\"variables\"][var_name].append(str(tf_path))\n",
    "\n",
    "        # 2. Modules\n",
    "        for mod_blk in body.get(\"module\", []):\n",
    "            for mod_label, attrs in mod_blk.items():\n",
    "                src = attrs.get(\"source\", \"(source not set)\")\n",
    "                collected[\"modules\"][mod_label].append((src, str(tf_path)))\n",
    "\n",
    "        # 3. Resources\n",
    "        for res_blk in body.get(\"resource\", []):\n",
    "            for res_type, instances in res_blk.items():\n",
    "                for res_name in instances:\n",
    "                    key = f\"{res_type}.{res_name}\"\n",
    "                    collected[\"resources\"][key].append(str(tf_path))\n",
    "\n",
    "    return collected\n",
    "\n",
    "\n",
    "def main():\n",
    "    parser = argparse.ArgumentParser(description=\"Terraform inventory generator\")\n",
    "    parser.add_argument(\"root\", help=\"Path to Terraform project root\")\n",
    "    parser.add_argument(\"--json\", action=\"store_true\",\n",
    "                        help=\"Emit raw JSON instead of pretty text\")\n",
    "    args = parser.parse_args()\n",
    "\n",
    "    root_path = pathlib.Path(args.root).resolve()\n",
    "    if not root_path.is_dir():\n",
    "        sys.exit(f\"⛔  {root_path} is not a directory\")\n",
    "\n",
    "    inventory = scan_directory(root_path)\n",
    "\n",
    "    if args.json:\n",
    "        print(json.dumps(inventory, indent=2))\n",
    "        return\n",
    "\n",
    "    # --- Nicely formatted text output ---------------------------\n",
    "    def headline(title):  # simple section separator\n",
    "        print(f\"\\n{title}\\n\" + \"-\" * len(title))\n",
    "\n",
    "    headline(\"VARIABLES\")\n",
    "    for v, files in sorted(inventory[\"variables\"].items()):\n",
    "        for f in files:\n",
    "            print(f\"{v:<30}  ←  {f}\")\n",
    "\n",
    "    headline(\"MODULES\")\n",
    "    for m, metas in sorted(inventory[\"modules\"].items()):\n",
    "        for src, f in metas:\n",
    "            print(f\"{m:<30}  | source = {src:<40} | {f}\")\n",
    "\n",
    "    headline(\"RESOURCES\")\n",
    "    for r, files in sorted(inventory[\"resources\"].items()):\n",
    "        for f in files:\n",
    "            print(f\"{r:<40}  ←  {f}\")\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
